#!/usr/bin/env python
import hashlib

from ProtocolHandler import ProtocolHandler
from asyncsocket import AsyncNode
import logging
import argparse
import ConfigParser
import random
import re

from chord import Chord

logging.basicConfig(level=logging.DEBUG, format='[%(asctime)-15s %(levelname)s] %(message)s')
config = ConfigParser.RawConfigParser()
config.read('node.cfg')
protocol = ProtocolHandler()
initial_resource_list = 'initial_resources.txt'
add_resource_list = 'add_resources.txt'


def arguement_parser():
    parser = argparse.ArgumentParser(description='Create a socket server')
    parser.add_argument('-p', "--port", type=int, help='Port Number to use for the server', required=True)
    parser.add_argument('-f', "--file_count", type=int, help='Number of files in the initial list', required=False)
    args = parser.parse_args()
    return args


def read_config():
    cfg = type('obj', (object,), {})
    cfg.bs_address = protocol.format_addresses([config.get('bootstrap', 'address').split(':')])
    cfg.username = config.get('node', 'username')
    return cfg


def read_resource_txt(filename):
    data = open(filename, 'r').read().replace('\r', '').split('\n')
    search_list = []
    for index in range(len(data)):
        if len(data[index]) > 0 and data[index][0] != '#':
            search_list.append(data[index])

    return search_list


def format_filename(file_list):
    filem = []
    for filex in file_list:
        filem.append('_'.join(re.findall('[A-Za-z0-9_]+', filex)))
    return filem


def select_random_files(file_list, length):
    selected_files = []
    for i in range(length):
        selected_files.append(file_list.pop(int(random.random() * 1000) % len(file_list)))

    return selected_files


node = AsyncNode()
args = arguement_parser()
CONFIG = read_config()
chord = Chord(node.get_address(), 2**(4*10))


@node.on('message')
def echoMessage(data, sock, address):
    response = protocol.parse_response(data)
    if response is not None:
        node.startevent(response['type'], response, sock)
    print data


@node.on('UPFIN')
def join_request(request, sock):
    if not request['is_response']:
        if not request['is_leaving']:
            chord.add_node(request['clients'])
        else:
            chord.delete_node(request['clients'])
        node.send_data(None, protocol.update_finger_response(0), sock=sock)


@node.on('join_request')
def send_join_requests(clientlist):
    chord.initialize_range(clientlist)
    for addr in chord.get_peer_list():
        node.send_data(addr, protocol.update_finger_request(protocol.JOIN, node.get_address(), chord.get_nodeid()))
        # TODO: Update Leave


@node.on('register')
def bootstrap_registration(data, *args, **kwargs):
    global NODE_ID
    response = protocol.parse_response(data)
    # If Registraton failed, De register and Re register
    if response['error_code'] == 9998:
        node.send_data(CONFIG.bs_address, protocol.deregister_ip_request(node.get_address(), 'ALPHA'))
        node.send_data(CONFIG.bs_address, protocol.register_request(node.get_address(), 'ALPHA'), event='register',
                       retry_count=1)
        return

    # Get all members from the server
    response = protocol.parse_response(
        node.send_data(CONFIG.bs_address, protocol.list_all(CONFIG.username), no_thread=True))
    clientlist = response['clients']
    node.startevent('join_request', clientlist)


@node.on('start')
def bootstrap_registration():
    # Create node ID
    logging.debug('Using sha1 node id:%d' % (chord.get_nodeid()))
    # Register with Bootstrap server
    node.send_data(CONFIG.bs_address, protocol.register_request(node.get_address(), CONFIG.username), event='register')

    node_file_list = format_filename(
        select_random_files(read_resource_txt(initial_resource_list), args.file_count or 7))
    chord.initialize_files(node_file_list)


@node.on('stop')
def deregister():
    for addr in chord.get_peer_list():
        node.send_data(addr, protocol.update_finger_request(protocol.LEAVE, node.address, chord.get_nodeid()))


if __name__ == '__main__':
    node.start(port=args.port)
