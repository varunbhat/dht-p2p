#!/usr/bin/env python
import hashlib

import time

from ProtocolHandler import ProtocolHandler
from asyncsocket import AsyncNode
import logging
import argparse
import ConfigParser
import random
import re

from chord import Chord

logging.basicConfig(level=logging.DEBUG, format='[%(asctime)-15s %(levelname)s] %(message)s')
config = ConfigParser.RawConfigParser()
config.read('node.cfg')
protocol = ProtocolHandler()
initial_resource_list = 'initial_resources.txt'
add_resource_list = 'add_resources.txt'


def arguement_parser():
    parser = argparse.ArgumentParser(description='Create a socket server')
    parser.add_argument('-p', "--port", type=int, help='Port Number to use for the server', required=True)
    parser.add_argument('-f', "--file_count", type=int, help='Number of files in the initial list', required=False)
    args = parser.parse_args()
    return args


def read_config():
    cfg = type('obj', (object,), {})
    cfg.bs_address = protocol.format_addresses([config.get('bootstrap', 'address').split(':')])
    cfg.username = config.get('node', 'username')
    return cfg


def read_resource_txt(filename):
    data = open(filename, 'r').read().replace('\r', '').split('\n')
    search_list = []
    for index in range(len(data)):
        if len(data[index]) > 0 and data[index][0] != '#':
            search_list.append(data[index])

    return search_list


def format_filename(file_list):
    filem = []
    for filex in file_list:
        filem.append('_'.join(re.findall('[A-Za-z0-9_]+', filex)))
    return filem


def select_random_files(file_list, length):
    selected_files = []
    for i in range(length):
        selected_files.append(file_list.pop(int(random.random() * 1000) % len(file_list)))

    return selected_files


args = arguement_parser()
node = AsyncNode(address=('127.0.0.1', args.port))
CONFIG = read_config()
chord = Chord(node.get_address(), 2 ** (4 * 4))


@node.on('message')
def echoMessage(data, sock, address):
    response = protocol.parse_response(data)
    if response is not None:
        return node.startevent(response['type'], response, sock)
    print data


@node.on('UPFIN')
def join_request(request, sock):
    if not request['is_response']:
        if not request['is_leaving']:
            chord.add_node(request['clients'])
        else:
            chord.delete_node(request['clients'])
        node.send_data(None, protocol.update_finger_response(0), sock=sock)


@node.on('GETKY')
def get_file_keys(request, sock):
    if request['is_Response']:
        print 'Invalid_response'
        return

    if request['key'] != chord.get_nodeid():
        getkey_resp = protocol.parse_response(
            node.send_data(chord.successor, protocol.get_key_request(request['key']), no_thread=True))

        node_req_files = chord.get_file_keymap(request['key'])

        if node_req_files is not None:
            getkey_resp['keymap'] += node_req_files
    else:
        return protocol.get_key_response([])


@node.on('join_request')
def send_join_requests(clientlist):
    chord.initialize_range(clientlist)
    for addr in chord.get_peer_list():
        if addr != node.get_address():
            node.send_data(addr, protocol.update_finger_request(protocol.JOIN, node.get_address(), chord.get_nodeid()))


@node.on('register')
def bootstrap_registration(data, *args, **kwargs):
    response = protocol.parse_response(data)
    # If Registraton failed, De register and Re register
    if response['error_code'] == 9998:
        node.send_data(CONFIG.bs_address, protocol.deregister_ip_request(node.get_address(), 'ALPHA'), no_thread=True)
        node.send_data(CONFIG.bs_address, protocol.register_request(node.get_address(), 'ALPHA'), event='register',
                       retry_count=1)
        return

    print response

    # Get all members from the server
    response = protocol.parse_response(
        node.send_data(CONFIG.bs_address, protocol.list_all(CONFIG.username), no_thread=True))
    clientlist = response['clients']
    node.startevent('join_request', clientlist)


@node.on('start')
def bootstrap_registration():
    # Create node ID
    logging.debug('Using sha1 node id:%d' % (chord.get_nodeid()))
    # Register with Bootstrap server
    node.send_data(CONFIG.bs_address, protocol.register_request(node.get_address(), CONFIG.username), event='register')

    node_file_list = format_filename(
        select_random_files(read_resource_txt(initial_resource_list), args.file_count or 7))
    chord.initialize_files(node_file_list)

    # node.send_data(chord.successor,)


@node.on('loop')
def monitor_commands():
    ip, port = node.get_address()
    input_read = raw_input('%s@%s:%d %s> ' % (CONFIG.username, ip, port, chord.get_nodeid()))
    input_read = input_read.lower()

    try:
        if input_read == 'details':
            print 'IP     :', node.get_address()
            print 'KEY    :', chord.get_nodeid()
        elif input_read == 'fingertable':
            ft = chord.get_finger_table()
            ids =ft.keys()
            ids.sort()

            for key in ids:
                print 'ID: ', str(key).zfill(15), 'Addr:', ft[key]
            print 'Predecessor:', chord.get_predecessor()
            print 'Successor  :', chord.get_successor()
            print 'Span       :', chord.get_span()
        elif input_read == 'entries':
            if len(chord.get_node_filemap()) > 0:
                for key, name in chord.get_node_filemap().iteritems():
                    print str(key).zfill(15), ':', name
            else:
                print 'Empty'
        elif input_read == 'keytable':
            if chord.get_peer_filemap():
                for key, name in chord.get_peer_filemap().iteritems():
                    print str(key).zfill(15), ':', name
            else:
                print 'Empty'
        elif input_read == 'exit':
            node.stop()
            return
        elif input_read == 'exitall':
            node.stop()
            return
    except Exception, e:
        print e
        pass


@node.on('stop')
def deregister():
    for addr in chord.get_peer_list():
        node.send_data(addr, protocol.update_finger_request(protocol.LEAVE, node.address, chord.get_nodeid()))
    node.send_data(CONFIG.bs_address, protocol.deregister_ip_request(node.address, CONFIG.username))


if __name__ == '__main__':
    node.start(ip='127.0.0.1', port=args.port)
