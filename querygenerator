#!/usr/bin/env python
import uuid

import networkx as nx
import matplotlib.pyplot as plt
import scipy.special as sps
from BootstrapProtocol import BootstrapProtocol
import socket
import json
import numpy as np
import random
import time
import redis
from PeerProtocol import PeerProtocol

bp = BootstrapProtocol('ALPHA')

# BOOTSTRAP_ADDRESS = ("129.82.46.190", 10000)
# BOOTSTRAP_ADDRESS = ("129.82.46.191", 10000)
# BOOTSTRAP_ADDRESS = ("129.82.46.204", 10000)
BOOTSTRAP_ADDRESS = ("129.82.46.207", 10000)
# BOOTSTRAP_ADDRESS = ("129.82.46.225", 10000)
# BOOTSTRAP_ADDRESS = ("129.82.46.226", 10000)
# BOOTSTRAP_ADDRESS = ("129.82.46.231", 10000)

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(10)

r = redis.Redis(
    host='redis.varunbhat.in',
    port=6379
)


def send(data, address, response=True):
    sock.sendto(data, address)
    if response:
        data = sock.recv(100000000)
        return data
    else:
        return None


def clear_bootstrap():
    print send(bp.deregister_all('ALPHA'), BOOTSTRAP_ADDRESS, True)


def read_resource_txt():
    data = open('resources.txt', 'r').read().replace('\r', '').split('\n')
    search_list = []
    for index in range(len(data)):
        if len(data[index]) > 0 and data[index][0] != '#':
            search_list.append(data[index])

    return search_list


def get_clients():
    return bp.parse_response(send(bp.list_all(), BOOTSTRAP_ADDRESS))['clients']


def get_network_config(addresses, neighbours):
    G = nx.Graph()
    G.add_nodes_from(addresses)

    for i in range(len(addresses)):
        edges = [(addresses[i], node) for node in neighbours[i]]
        G.add_edges_from(edges)
    return G


def get_node_details(clients):
    node_names = r.hgetall('global_clients')
    out_connections = []
    addresses = []
    app_names = []

    for node_name, key in node_names.iteritems():
        ip, port, olist = r.hmget(key, ('IP', 'PORT', 'OLIST'))
        addr = (ip, int(port))
        if addr in clients:
            addresses.append(addr)
            olist = [laddr.split(':') for laddr in r.smembers(olist)]
            olist = [(ip, int(port)) for ip, port in olist]
            out_connections.append(olist)
            app_names.append(node_name)
    return app_names, addresses, out_connections


def node_degree(graph):
    degree = []
    for client in graph.nodes():
        degree.append(len(graph.predecessors(client)))
    return sum(degree) / float(len(degree))


def get_graph(graph, filename='test.png'):
    nx.draw_circular(graph)
    plt.savefig(filename)
    plt.show()


def set_file_count(value):
    r.publish('SERVER_COMMANDS', json.dumps({'command': 'read_files', 'file_count': value}))


def get_files(node_names):
    file_info = []
    for node in node_names:
        file_info.append(list(r.smembers(r.hget(r.hget("global_clients", node), 'FILES'))))
    return file_info


def plot_file_distribution(resources, file_distribution, filename):
    count = [0 for i in range(len(resources))]

    for node_fil_arr in file_distribution:
        for lfile in node_fil_arr:
            count[resources.index(lfile)] += 1

    plt.clf()
    y_pos = np.arange(len(resources))
    plt.bar(y_pos, count, align='center', alpha=0.5)
    # plt.xticks(y_pos, resources)
    plt.ylabel('Number of Nodes')
    plt.title('File Distribution')
    plt.savefig(filename)

    plt.show()
    pass


def execute_search(resources, clients, ns):
    pp = PeerProtocol()

    x = np.arange(1., 160.)
    a = .7
    y = x ** (-a) / sps.zetac(a)

    # plt.clf()
    # plt.plot(x, y / max(y), linewidth=2, color='r')
    # plt.savefig('zipfs.png')

    file_count = [int(abs(count)) for count in (y / max(y))]
    print "Number of files to be sent", sum(file_count)

    plt.clf()
    plt.plot(x, file_count, linewidth=2, color='r')
    plt.savefig('zipfs.png')

    for i in range(len(file_count)):
        if not file_count[i] > 0:
            file_count[i] = 1

    while sum(file_count) > 0:
        file_index = int(random.random() * 1000) % len(file_count)
        if file_count[file_index] > 0:
            file_count[file_index] -= 1
        else:
            continue

        index = int(random.random() * 1000) % len(clients)

        ip, port = clients[index]
        send(pp.search_request(ip, port, resources[file_index], uuid.uuid4(), 0), clients[index], response=False)
        time.sleep(0.4)


def calculate_1(hopcount):
    hops = []
    latency = []
    msg_count = []

    for i in range(r.llen("global_search_results")):
        data = json.loads(r.lpop('global_search_results'))
        hops.append(int(data['hop_count']))
        latency.append(float(data['response_time']) - float(data['start_time']))

    if hopcount > 0:
        print "Hops     :", "Min:", min(hops)+1, "Max:", max(hops)+1, "average:", 1 + sum(hops)/(1.25*hopcount) / float(len(hops)), "SD:", 1+ np.std(
            hops)/(1.25*hopcount)
        print "Latency  :", "Min:", min(latency), "Max:", max(latency), "average:", sum(latency) / float(
            len(latency)), "SD:", np.std(latency)
    else:
        print "Hops     :", "Min:", min(hops)+1, "Max:", max(hops)+1, "average:", sum(hops) / float(len(hops)), "SD:", np.std(
            hops)
        print "Latency  :", "Min:", min(latency), "Max:", max(latency), "average:", sum(latency) / float(
            len(latency)), "SD:", np.std(latency)

    H, X1 = np.histogram(hops, bins=10, normed=True)
    dx = X1[1] - X1[0]
    F1 = np.cumsum(H) * dx

    plt.clf()
    plt.plot(X1[1:], F1)
    plt.savefig('%s_cdf_hops.png' % (str(hopcount)))

    H, X1 = np.histogram(latency, bins=10, normed=True)
    dx = X1[1] - X1[0]
    F1 = np.cumsum(H) * dx

    plt.clf()
    plt.plot(X1[1:], F1)
    plt.savefig('%s_cdf_latency.png' % (str(hopcount)))

    # print "Msg Count:", "Min:", min(msg_count), "Max:", max(msg_count), "average:", sum(msg_count) / float(
    #     len(msg_count)), "SD:", np.std(
    #     msg_count)


if __name__ == '__main__':
    print "Clearing the from Bootstrap server..."
    clear_bootstrap()

    print 'Asking clients to register with the network',
    r.publish('SERVER_COMMANDS', json.dumps({'command': 'register_bootstrap'}))
    time.sleep(10)

    print "Getting Bootstrap commands from the server"
    clients = get_clients()
    print "Clients:"
    for i in clients:
        print i

    node_names, addresses, neighbours = get_node_details(clients)

    print "Number of Nodes:", len(clients)
    graph = get_network_config(clients, neighbours)

    degree = []
    for client in graph.nodes():
        degree.append(len(graph.neighbors(client)))
    nd1 = sum(degree) / float(len(degree))

    print "Average Node Degree:", nd1, "Max:", max(degree), "Min:", min(degree)
    get_graph(graph, str(len(clients)) + '_config.png')

    if len(clients) >= 80:
        set_file_count(2)
    elif len(clients) >= 40:
        set_file_count(4)
    else:
        set_file_count(8)

    resources = read_resource_txt()
    file_arr = get_files(node_names)
    plot_file_distribution(resources, file_arr, str(len(clients)) + '_file_distribution.png')

    hopcounts = [0, 1, 2, 4]

    try:
        for hops in hopcounts:
            print "Executing search for hops=", hops
            r.publish('SERVER_COMMANDS', json.dumps({'command': 'set_cache_size', 'cache_enabled': 1, 'cache_size': hops}))
            time.sleep(3)
            execute_search(resources, clients, 1)
            raw_input('Wait until the search is complete in the network then press enter.')
            calculate_1(hops)
    except KeyboardInterrupt:
        clear_bootstrap()
